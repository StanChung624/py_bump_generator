from __future__ import annotations

import math
from typing import Tuple

from VBumpDef import VBump, to_csv, _require_h5py, _require_numpy


def estimate_rectangular_area_XY_by_pitch_count(
    p0: Tuple[float],
    p1: Tuple[float],
    x_pitch: float,
    y_pitch: float,
) -> int:
    """Estimate how many vbumps will be generated by the pitch-based routine."""
    if x_pitch <= 0 or y_pitch <= 0:
        raise ValueError("Pitch values must be positive.")
    width = abs(p1[0] - p0[0])
    height = abs(p1[1] - p0[1])
    nx = math.ceil(width / x_pitch) if width else 0
    ny = math.ceil(height / y_pitch) if height else 0
    return nx * ny


def estimate_rectangular_area_XY_by_number_count(
    x_num: int,
    y_num: int,
) -> int:
    """Estimate how many vbumps will be generated by the count-based routine."""
    if x_num < 0 or y_num < 0:
        raise ValueError("Counts must be non-negative.")
    return x_num * y_num


def create_rectangular_area_XY_by_pitch(
        p0:Tuple[float], p1:Tuple[float],
        x_pitch:float, y_pitch:float,
        diameter:float, group:int,
        z:float, height:float):

    ret = []

    xmin = p0[0] if p0[0] < p1[0] else p1[0]
    ymin = p0[1] if p0[1] < p1[1] else p1[1]
    xmax = p0[0] if p0[0] > p1[0] else p1[0]
    ymax = p0[1] if p0[1] > p1[1] else p1[1]

    x = xmin; y = ymin

    while x < xmax:
        while y < ymax:
            ret.append(VBump.from_coords(x, y, z, x, y, z + height, diameter, group))
            y += y_pitch
        x+= x_pitch
        y = ymin

    print(f"âœ… {len(ret)}  vbumps has been created.")
    return ret


def create_rectangular_area_XY_by_number(
        p0:Tuple[float], p1:Tuple[float],
        x_num:int, y_num:int,
        diameter:float, group:int,
        z:float, height:float):

    x_pitch = abs(p1[0] - p0[0]) / x_num
    y_pitch = abs(p1[1] - p0[1]) / y_num

    new_p0, new_p1 = [0,0], [0,0]

    new_p0[0] = (p0[0] + p1[0])/2 - (x_num/2)*x_pitch
    new_p1[0] = (p0[0] + p1[0])/2 + (x_num/2)*x_pitch
    new_p0[1] = (p0[1] + p1[1])/2 - (y_num/2)*y_pitch
    new_p1[1] = (p0[1] + p1[1])/2 + (y_num/2)*y_pitch

    return create_rectangular_area_XY_by_pitch(
        new_p0, new_p1, x_pitch, y_pitch, diameter, group, z, height)


def create_rectangular_area_XY_by_pitch_to_hdf5(
    filepath: str,
    p0: Tuple[float],
    p1: Tuple[float],
    x_pitch: float,
    y_pitch: float,
    diameter: float,
    group: int,
    z: float,
    height: float,
    *,
    chunk_size: int = 1_000_000,
    compression: str | int | None = "gzip",
    progress: bool = True,
    progress_interval: int | None = None,
) -> int:
    """Stream large pitch-based grids directly into an HDF5 dataset.

    Stores a `bounding_box` attribute on the resulting dataset with rows `[min, max]`
    and columns `[x, y, z]`, where x/y extents include the bump radius. The same
    bounding box is mirrored under `groups/<group>/bounding_box` so consumers can
    access per-group extents without scanning the dataset.
    """
    if chunk_size <= 0:
        raise ValueError("chunk_size must be positive.")
    total_estimate = estimate_rectangular_area_XY_by_pitch_count(p0, p1, x_pitch, y_pitch)
    h5py = _require_h5py()
    np = _require_numpy()
    dtype = np.dtype([
        ("x0", np.float64),
        ("y0", np.float64),
        ("z0", np.float64),
        ("x1", np.float64),
        ("y1", np.float64),
        ("z1", np.float64),
        ("D", np.float64),
        ("group", np.int32),
    ])

    xmin = p0[0] if p0[0] < p1[0] else p1[0]
    ymin = p0[1] if p0[1] < p1[1] else p1[1]
    xmax = p0[0] if p0[0] > p1[0] else p1[0]
    ymax = p0[1] if p0[1] > p1[1] else p1[1]
    z1 = z + height

    nx = math.ceil(abs(xmax - xmin) / x_pitch) if abs(xmax - xmin) else 0
    ny = math.ceil(abs(ymax - ymin) / y_pitch) if abs(ymax - ymin) else 0

    if total_estimate == 0:
        with h5py.File(filepath, "w") as handle:
            handle.create_dataset("vbump", shape=(0,), maxshape=(None,), dtype=dtype)
        if progress:
            print("... 0/0 (0.0%)", flush=True)
        print(f"ðŸ“¦ Successfully streamed 0 vbumps into {filepath} (estimated 0).")
        return 0

    chunk_len = max(1, min(chunk_size, total_estimate or chunk_size))

    if progress and total_estimate:
        if progress_interval is None:
            progress_interval = max(chunk_len, total_estimate // 100 or 1)
        else:
            progress_interval = max(1, progress_interval)
    else:
        progress_interval = None

    with h5py.File(filepath, "w") as handle:
        dset = handle.create_dataset(
            "vbump",
            shape=(0,),
            maxshape=(None,),
            dtype=dtype,
            compression=compression,
            chunks=(chunk_len,),
        )
        buffer = np.empty((chunk_len,), dtype=dtype)
        buf_pos = 0
        written = 0
        last_report = 0
        bbox_min = [math.inf, math.inf, math.inf]
        bbox_max = [-math.inf, -math.inf, -math.inf]
        z_min = min(z, z1)
        z_max = max(z, z1)
        half_d = diameter / 2

        for ix in range(nx):
            x = xmin + ix * x_pitch
            if x >= xmax:
                break
            for iy in range(ny):
                y_val = ymin + iy * y_pitch
                if y_val >= ymax:
                    break
                x_min_candidate = x - half_d
                x_max_candidate = x + half_d
                y_min_candidate = y_val - half_d
                y_max_candidate = y_val + half_d
                buffer[buf_pos] = (
                    x,
                    y_val,
                    z,
                    x,
                    y_val,
                    z1,
                    diameter,
                    group,
                )
                if x_min_candidate < bbox_min[0]:
                    bbox_min[0] = x_min_candidate
                if y_min_candidate < bbox_min[1]:
                    bbox_min[1] = y_min_candidate
                if x_max_candidate > bbox_max[0]:
                    bbox_max[0] = x_max_candidate
                if y_max_candidate > bbox_max[1]:
                    bbox_max[1] = y_max_candidate
                buf_pos += 1
                if buf_pos == buffer.shape[0]:
                    dset.resize((written + buf_pos,))
                    dset[written:written + buf_pos] = buffer
                    written += buf_pos
                    buf_pos = 0
                    if progress_interval and written - last_report >= progress_interval:
                        last_report = written
                        pct = written / total_estimate * 100
                        print(f"... {written}/{total_estimate} ({pct:.1f}%)", flush=True)
        if buf_pos:
            dset.resize((written + buf_pos,))
            dset[written:written + buf_pos] = buffer[:buf_pos]
            written += buf_pos
            if progress_interval and written - last_report >= progress_interval:
                last_report = written
                pct = written / total_estimate * 100 if total_estimate else 0.0
                print(f"... {written}/{total_estimate} ({pct:.1f}%)", flush=True)
        if written:
            bbox_min[2] = z_min
            bbox_max[2] = z_max
            bbox_array = np.array([bbox_min, bbox_max], dtype=np.float64)
            dset.attrs["bounding_box"] = bbox_array
            groups_root = handle.create_group("groups")
            group_node = groups_root.create_group(str(group))
            group_node.attrs["bounding_box"] = bbox_array

    if progress and total_estimate and written != last_report:
        pct = written / total_estimate * 100
        print(f"... {written}/{total_estimate} ({pct:.1f}%)", flush=True)
    print(f"ðŸ“¦ Successfully streamed {written} vbumps into {filepath} (estimated {total_estimate}).")
    return written

def create_rectangular_area_XY_by_number_to_hdf5(
    filepath: str,
    p0: Tuple[float],
    p1: Tuple[float],
    x_num: int,
    y_num: int,
    diameter: float,
    group: int,
    z: float,
    height: float,
    *,
    chunk_size: int = 1_000_000,
    compression: str | int | None = "gzip",
    progress: bool = True,
    progress_interval: int | None = None,
) -> int:
    """Stream count-based grids directly into an HDF5 dataset.

    Delegates to the pitch-based routine, inheriting the `bounding_box`
    metadata that captures the overall extents.
    """
    if x_num <= 0 or y_num <= 0:
        raise ValueError("Counts must be positive for streaming output.")
    x_pitch = abs(p1[0] - p0[0]) / x_num
    y_pitch = abs(p1[1] - p0[1]) / y_num
    new_p0 = [0.0, 0.0]
    new_p1 = [0.0, 0.0]
    new_p0[0] = (p0[0] + p1[0]) / 2 - (x_num / 2) * x_pitch
    new_p1[0] = (p0[0] + p1[0]) / 2 + (x_num / 2) * x_pitch
    new_p0[1] = (p0[1] + p1[1]) / 2 - (y_num / 2) * y_pitch
    new_p1[1] = (p0[1] + p1[1]) / 2 + (y_num / 2) * y_pitch
    return create_rectangular_area_XY_by_pitch_to_hdf5(
        filepath,
        tuple(new_p0),
        tuple(new_p1),
        x_pitch,
        y_pitch,
        diameter,
        group,
        z,
        height,
        chunk_size=chunk_size,
        compression=compression,
        progress=progress,
        progress_interval=progress_interval,
    )


if __name__ == "__main__":

    stats = create_rectangular_area_XY_by_number_to_hdf5(
        filepath='large_test.h5',
        p0 = (0,0), p1= (100, 100),
        x_num=20_000, y_num=20_000,
        group=1, height=1,
        diameter= 0.15, z=0)
